use crate::prelude::*;
use air_r_syntax::RRoot;
use air_r_syntax::RRootFields;
use air_r_syntax::RSyntaxNode;
use biome_formatter::write;
use biome_formatter::CstFormatContext;
use biome_rowan::Direction;
use biome_rowan::SyntaxElement;

#[derive(Debug, Clone, Default)]
pub(crate) struct FormatRRoot;

impl FormatRRoot {
    fn is_suppression_comment(text: &str) -> bool {
        let text = text.trim_start_matches('#').trim();

        // Air-specific escape hatch
        if text == "fmt: skip file" {
            return true;
        }

        // Convention used in the R community (Roxygen, Rcpp, etc)
        if text.starts_with("Generated by") {
            return true;
        }

        // Convention used in some programming language communities
        if text.contains("@generated") {
            return true;
        }

        false
    }
}

impl FormatNodeRule<RRoot> for FormatRRoot {
    fn fmt_fields(&self, node: &RRoot, f: &mut RFormatter) -> FormatResult<()> {
        let RRootFields {
            bom_token,
            expressions,
            eof_token,
        } = node.as_fields();

        write!(
            f,
            [
                bom_token.format(),
                expressions.format(),
                hard_line_break(),
                format_removed(&eof_token?),
            ]
        )
    }

    fn is_suppressed(&self, node: &RRoot, f: &RFormatter) -> bool {
        let Some(child) = node.expressions().first() else {
            return false;
        };

        let comments = f.context().comments();

        // Only consider very first comment in the file
        let Some(comment) = comments.leading_comments(child.syntax()).first() else {
            return false;
        };

        Self::is_suppression_comment(comment.piece().text())
    }

    // The default handling of suppressed nodes in `FormatNodeRule::fmt()`
    // does not work out well for `RRoot` because it doesn't format
    // trivia verbatim. So we use a custom implementation instead.
    fn fmt_suppressed(&self, node: &RRoot, f: &mut RFormatter) -> FormatResult<()> {
        let RRootFields { bom_token, .. } = node.as_fields();
        write!(f, [bom_token.format()])?;

        // Mark everything as visited so the formatter doesn't panic
        // thinking we've missed elements. We're going to print each element
        // manually with `dynamic_text()`.
        mark_visited(node.syntax(), f);

        // `node.text()` trims trivia so we get the raw text on the syntax
        // node instead
        let text: String = node.syntax().text().into();

        // Formatting with `format_suppressed_node()` does not work well
        // here because it only formats the node verbatim, not the leading
        // and trailing trivia
        dynamic_text(&text, node.syntax().text_range().start()).fmt(f)
    }
}

// Copied from `biome_formatter::FormatVerbatimNode.fmt()`
fn mark_visited(node: &RSyntaxNode, f: &mut RFormatter) {
    for element in node.descendants_with_tokens(Direction::Next) {
        match element {
            SyntaxElement::Token(token) => f.state_mut().track_token(&token),
            SyntaxElement::Node(node) => {
                let comments = f.context().comments();
                comments.mark_suppression_checked(&node);

                for comment in comments.leading_dangling_trailing_comments(&node) {
                    comment.mark_formatted();
                }
            }
        }
    }
}
